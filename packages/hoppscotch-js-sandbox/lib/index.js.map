{"version":3,"sources":["../src/index.ts","../src/preRequest.ts","../src/utils.ts","../src/test-runner.ts"],"names":[],"mappings":"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","sourcesContent":["import { pipe } from \"fp-ts/function\"\nimport * as TE from \"fp-ts/TaskEither\"\nimport { execPreRequestScript } from \"./preRequest\"\nimport {\n  execTestScript,\n  TestResponse as _TestResponse,\n  TestDescriptor as _TestDescriptor,\n  TestResult,\n} from \"./test-runner\"\n\nexport * from \"./test-runner\"\n\nexport type TestResponse = _TestResponse\nexport type TestDescriptor = _TestDescriptor\nexport type SandboxTestResult = TestResult & { tests: TestDescriptor }\n\n/**\n * Executes a given test script on the test-runner sandbox\n * @param testScript The string of the script to run\n * @returns A TaskEither with an error message or a TestDescriptor with the final status\n */\nexport const runTestScript = (\n  testScript: string,\n  envs: TestResult[\"envs\"],\n  response: TestResponse\n) =>\n  pipe(\n    execTestScript(testScript, envs, response),\n    TE.chain((results) =>\n      TE.right(<SandboxTestResult>{\n        envs: results.envs,\n        tests: results.tests[0],\n      })\n    ) // execTestScript returns an array of descriptors with a single element (extract that)\n  )\n\n/**\n * Executes a given pre-request script on the sandbox\n * @param preRequestScript The script to run\n * @param env The environment variables active\n * @returns A TaskEither with an error message or an array of the final environments with the all the script values applied\n */\nexport const runPreRequestScript = execPreRequestScript\n","import { pipe } from \"fp-ts/function\"\nimport * as O from \"fp-ts/Option\"\nimport * as E from \"fp-ts/Either\"\nimport * as TE from \"fp-ts/lib/TaskEither\"\nimport * as qjs from \"quickjs-emscripten\"\nimport cloneDeep from \"lodash/clone\"\nimport { Environment, parseTemplateStringE } from \"@hoppscotch/data\"\nimport { getEnv, setEnv } from \"./utils\"\n\ntype Envs = {\n  global: Environment[\"variables\"]\n  selected: Environment[\"variables\"]\n}\n\nexport const execPreRequestScript = (\n  preRequestScript: string,\n  envs: Envs\n): TE.TaskEither<string, Envs> =>\n  pipe(\n    TE.tryCatch(\n      async () => await qjs.getQuickJS(),\n      (reason) => `QuickJS initialization failed: ${reason}`\n    ),\n    TE.chain((QuickJS) => {\n      let currentEnvs = cloneDeep(envs)\n\n      const vm = QuickJS.createVm()\n\n      const pwHandle = vm.newObject()\n\n      // Environment management APIs\n      // TODO: Unified Implementation\n      const envHandle = vm.newObject()\n\n      const envGetHandle = vm.newFunction(\"get\", (keyHandle) => {\n        const key: unknown = vm.dump(keyHandle)\n\n        if (typeof key !== \"string\") {\n          return {\n            error: vm.newString(\"Expected key to be a string\"),\n          }\n        }\n\n        const result = pipe(\n          getEnv(key, currentEnvs),\n          O.match(\n            () => vm.undefined,\n            ({ value }) => vm.newString(value)\n          )\n        )\n\n        return {\n          value: result,\n        }\n      })\n\n      const envGetResolveHandle = vm.newFunction(\"getResolve\", (keyHandle) => {\n        const key: unknown = vm.dump(keyHandle)\n\n        if (typeof key !== \"string\") {\n          return {\n            error: vm.newString(\"Expected key to be a string\"),\n          }\n        }\n\n        const result = pipe(\n          getEnv(key, currentEnvs),\n          E.fromOption(() => \"INVALID_KEY\" as const),\n\n          E.map(({ value }) =>\n            pipe(\n              parseTemplateStringE(value, [...envs.selected, ...envs.global]),\n              // If the recursive resolution failed, return the unresolved value\n              E.getOrElse(() => value)\n            )\n          ),\n\n          // Create a new VM String\n          // NOTE: Do not shorten this to map(vm.newString) apparently it breaks it\n          E.map((x) => vm.newString(x)),\n\n          E.getOrElse(() => vm.undefined)\n        )\n\n        return {\n          value: result,\n        }\n      })\n\n      const envSetHandle = vm.newFunction(\"set\", (keyHandle, valueHandle) => {\n        const key: unknown = vm.dump(keyHandle)\n        const value: unknown = vm.dump(valueHandle)\n\n        if (typeof key !== \"string\") {\n          return {\n            error: vm.newString(\"Expected key to be a string\"),\n          }\n        }\n\n        if (typeof value !== \"string\") {\n          return {\n            error: vm.newString(\"Expected value to be a string\"),\n          }\n        }\n\n        currentEnvs = setEnv(key, value, currentEnvs)\n\n        return {\n          value: vm.undefined,\n        }\n      })\n\n      const envResolveHandle = vm.newFunction(\"resolve\", (valueHandle) => {\n        const value: unknown = vm.dump(valueHandle)\n\n        if (typeof value !== \"string\") {\n          return {\n            error: vm.newString(\"Expected value to be a string\"),\n          }\n        }\n\n        const result = pipe(\n          parseTemplateStringE(value, [\n            ...currentEnvs.selected,\n            ...currentEnvs.global,\n          ]),\n          E.getOrElse(() => value)\n        )\n\n        return {\n          value: vm.newString(result),\n        }\n      })\n\n      vm.setProp(envHandle, \"resolve\", envResolveHandle)\n      envResolveHandle.dispose()\n\n      vm.setProp(envHandle, \"set\", envSetHandle)\n      envSetHandle.dispose()\n\n      vm.setProp(envHandle, \"getResolve\", envGetResolveHandle)\n      envGetResolveHandle.dispose()\n\n      vm.setProp(envHandle, \"get\", envGetHandle)\n      envGetHandle.dispose()\n\n      vm.setProp(pwHandle, \"env\", envHandle)\n      envHandle.dispose()\n\n      vm.setProp(vm.global, \"pw\", pwHandle)\n      pwHandle.dispose()\n\n      const evalRes = vm.evalCode(preRequestScript)\n\n      if (evalRes.error) {\n        const errorData = vm.dump(evalRes.error)\n        evalRes.error.dispose()\n\n        return TE.left(errorData)\n      }\n\n      vm.dispose()\n\n      return TE.right(currentEnvs)\n    })\n  )\n","import * as O from \"fp-ts/Option\"\nimport * as E from \"fp-ts/Either\"\nimport * as QuickJS from \"quickjs-emscripten\"\nimport { TestResult } from \"./test-runner\"\n\nexport function marshalObjectToVM(\n  vm: QuickJS.QuickJSVm,\n  obj: object\n): E.Either<string, QuickJS.QuickJSHandle> {\n  let jsonString\n\n  try {\n    jsonString = JSON.stringify(obj)\n  } catch (e) {\n    return E.left(\"Marshaling stringification failed\")\n  }\n\n  const vmStringHandle = vm.newString(jsonString)\n\n  const jsonHandle = vm.getProp(vm.global, \"JSON\")\n  const parseFuncHandle = vm.getProp(jsonHandle, \"parse\")\n\n  const parseResultHandle = vm.callFunction(\n    parseFuncHandle,\n    vm.undefined,\n    vmStringHandle\n  )\n\n  if (parseResultHandle.error) {\n    parseResultHandle.error.dispose()\n    return E.left(\"Marshaling failed\")\n  }\n\n  const resultHandle = vm.unwrapResult(parseResultHandle)\n\n  vmStringHandle.dispose()\n  parseFuncHandle.dispose()\n  jsonHandle.dispose()\n\n  return E.right(resultHandle)\n}\n\nexport function getEnv(envName: string, envs: TestResult[\"envs\"]) {\n  return O.fromNullable(\n    envs.selected.find((x) => x.key === envName) ??\n      envs.global.find((x) => x.key === envName)\n  )\n}\n\nexport function setEnv(\n  envName: string,\n  envValue: string,\n  envs: TestResult[\"envs\"]\n): TestResult[\"envs\"] {\n  const indexInSelected = envs.selected.findIndex((x) => x.key === envName)\n\n  // Found the match in selected\n  if (indexInSelected >= 0) {\n    envs.selected[indexInSelected].value = envValue\n\n    return {\n      global: envs.global,\n      selected: envs.selected,\n    }\n  }\n\n  const indexInGlobal = envs.global.findIndex((x) => x.key == envName)\n\n  // Found a match in globals\n  if (indexInGlobal >= 0) {\n    envs.global[indexInGlobal].value = envValue\n\n    return {\n      global: envs.global,\n      selected: envs.selected,\n    }\n  }\n\n  // Didn't find in both places, create a new variable in selected\n  envs.selected.push({\n    key: envName,\n    value: envValue,\n  })\n\n  return {\n    global: envs.global,\n    selected: envs.selected,\n  }\n}\n","import * as O from \"fp-ts/Option\"\nimport * as E from \"fp-ts/Either\"\nimport * as TE from \"fp-ts/TaskEither\"\nimport { pipe } from \"fp-ts/function\"\nimport * as qjs from \"quickjs-emscripten\"\nimport { Environment, parseTemplateStringE } from \"@hoppscotch/data\"\nimport cloneDeep from \"lodash/cloneDeep\"\nimport { getEnv, marshalObjectToVM, setEnv } from \"./utils\"\n\n/**\n * The response object structure exposed to the test script\n */\nexport type TestResponse = {\n  /** Status Code of the response */\n  status: number\n  /** List of headers returned */\n  headers: { key: string; value: string }[]\n  /**\n   * Body of the response, this will be the JSON object if it is a JSON content type, else body string\n   */\n  body: string | object\n}\n\n/**\n * The result of an expectation statement\n */\ntype ExpectResult = { status: \"pass\" | \"fail\" | \"error\"; message: string } // The expectation failed (fail) or errored (error)\n\n/**\n * An object defining the result of the execution of a\n * test block\n */\nexport type TestDescriptor = {\n  /**\n   * The name of the test block\n   */\n  descriptor: string\n\n  /**\n   * Expectation results of the test block\n   */\n  expectResults: ExpectResult[]\n\n  /**\n   * Children test blocks (test blocks inside the test block)\n   */\n  children: TestDescriptor[]\n}\n\n/**\n * Defines the result of a test script execution\n */\nexport type TestResult = {\n  tests: TestDescriptor[]\n  envs: {\n    global: Environment[\"variables\"]\n    selected: Environment[\"variables\"]\n  }\n}\n\n/**\n * Creates an Expectation object for use inside the sandbox\n * @param vm The QuickJS sandbox VM instance\n * @param expectVal The expecting value of the expectation\n * @param negated Whether the expectation is negated (negative)\n * @param currTestStack The current state of the test execution stack\n * @returns Handle to the expectation object in VM\n */\nfunction createExpectation(\n  vm: qjs.QuickJSVm,\n  expectVal: any,\n  negated: boolean,\n  currTestStack: TestDescriptor[]\n): qjs.QuickJSHandle {\n  const resultHandle = vm.newObject()\n\n  const toBeFnHandle = vm.newFunction(\"toBe\", (expectedValHandle) => {\n    const expectedVal = vm.dump(expectedValHandle)\n\n    let assertion = expectVal === expectedVal\n    if (negated) assertion = !assertion\n\n    if (assertion) {\n      currTestStack[currTestStack.length - 1].expectResults.push({\n        status: \"pass\",\n        message: `Expected '${expectVal}' to${\n          negated ? \" not\" : \"\"\n        } be '${expectedVal}'`,\n      })\n    } else {\n      currTestStack[currTestStack.length - 1].expectResults.push({\n        status: \"fail\",\n        message: `Expected '${expectVal}' to${\n          negated ? \" not\" : \"\"\n        } be '${expectedVal}'`,\n      })\n    }\n\n    return { value: vm.undefined }\n  })\n\n  const toBeLevel2xxHandle = vm.newFunction(\"toBeLevel2xx\", () => {\n    // Check if the expected value is a number, else it is an error\n    if (typeof expectVal === \"number\" && !Number.isNaN(expectVal)) {\n      let assertion = expectVal >= 200 && expectVal <= 299\n      if (negated) assertion = !assertion\n\n      if (assertion) {\n        currTestStack[currTestStack.length - 1].expectResults.push({\n          status: \"pass\",\n          message: `Expected '${expectVal}' to${\n            negated ? \" not\" : \"\"\n          } be 200-level status`,\n        })\n      } else {\n        currTestStack[currTestStack.length - 1].expectResults.push({\n          status: \"fail\",\n          message: `Expected '${expectVal}' to${\n            negated ? \" not\" : \"\"\n          } be 200-level status`,\n        })\n      }\n    } else {\n      currTestStack[currTestStack.length - 1].expectResults.push({\n        status: \"error\",\n        message: `Expected 200-level status but could not parse value '${expectVal}'`,\n      })\n    }\n\n    return { value: vm.undefined }\n  })\n\n  const toBeLevel3xxHandle = vm.newFunction(\"toBeLevel3xx\", () => {\n    // Check if the expected value is a number, else it is an error\n    if (typeof expectVal === \"number\" && !Number.isNaN(expectVal)) {\n      let assertion = expectVal >= 300 && expectVal <= 399\n      if (negated) assertion = !assertion\n\n      if (assertion) {\n        currTestStack[currTestStack.length - 1].expectResults.push({\n          status: \"pass\",\n          message: `Expected '${expectVal}' to${\n            negated ? \" not\" : \"\"\n          } be 300-level status`,\n        })\n      } else {\n        currTestStack[currTestStack.length - 1].expectResults.push({\n          status: \"fail\",\n          message: `Expected '${expectVal}' to${\n            negated ? \" not\" : \"\"\n          } be 300-level status`,\n        })\n      }\n    } else {\n      currTestStack[currTestStack.length - 1].expectResults.push({\n        status: \"error\",\n        message: `Expected 300-level status but could not parse value '${expectVal}'`,\n      })\n    }\n\n    return { value: vm.undefined }\n  })\n\n  const toBeLevel4xxHandle = vm.newFunction(\"toBeLevel4xx\", () => {\n    // Check if the expected value is a number, else it is an error\n    if (typeof expectVal === \"number\" && !Number.isNaN(expectVal)) {\n      let assertion = expectVal >= 400 && expectVal <= 499\n      if (negated) assertion = !assertion\n\n      if (assertion) {\n        currTestStack[currTestStack.length - 1].expectResults.push({\n          status: \"pass\",\n          message: `Expected '${expectVal}' to${\n            negated ? \" not\" : \"\"\n          } be 400-level status`,\n        })\n      } else {\n        currTestStack[currTestStack.length - 1].expectResults.push({\n          status: \"fail\",\n          message: `Expected '${expectVal}' to${\n            negated ? \" not\" : \"\"\n          } be 400-level status`,\n        })\n      }\n    } else {\n      currTestStack[currTestStack.length - 1].expectResults.push({\n        status: \"error\",\n        message: `Expected 400-level status but could not parse value '${expectVal}'`,\n      })\n    }\n\n    return { value: vm.undefined }\n  })\n\n  const toBeLevel5xxHandle = vm.newFunction(\"toBeLevel5xx\", () => {\n    // Check if the expected value is a number, else it is an error\n    if (typeof expectVal === \"number\" && !Number.isNaN(expectVal)) {\n      let assertion = expectVal >= 500 && expectVal <= 599\n      if (negated) assertion = !assertion\n\n      if (assertion) {\n        currTestStack[currTestStack.length - 1].expectResults.push({\n          status: \"pass\",\n          message: `Expected '${expectVal}' to${\n            negated ? \" not\" : \"\"\n          } be 500-level status`,\n        })\n      } else {\n        currTestStack[currTestStack.length - 1].expectResults.push({\n          status: \"fail\",\n          message: `Expected '${expectVal}' to${\n            negated ? \" not\" : \"\"\n          } be 500-level status`,\n        })\n      }\n    } else {\n      currTestStack[currTestStack.length - 1].expectResults.push({\n        status: \"error\",\n        message: `Expected 500-level status but could not parse value '${expectVal}'`,\n      })\n    }\n\n    return { value: vm.undefined }\n  })\n\n  const toBeTypeHandle = vm.newFunction(\"toBeType\", (expectedValHandle) => {\n    const expectedType = vm.dump(expectedValHandle)\n\n    // Check if the expectation param is a valid type name string, else error\n    if (\n      [\n        \"string\",\n        \"boolean\",\n        \"number\",\n        \"object\",\n        \"undefined\",\n        \"bigint\",\n        \"symbol\",\n        \"function\",\n      ].includes(expectedType)\n    ) {\n      let assertion = typeof expectVal === expectedType\n      if (negated) assertion = !assertion\n\n      if (assertion) {\n        currTestStack[currTestStack.length - 1].expectResults.push({\n          status: \"pass\",\n          message: `Expected '${expectVal}' to${\n            negated ? \" not\" : \"\"\n          } be type '${expectedType}'`,\n        })\n      } else {\n        currTestStack[currTestStack.length - 1].expectResults.push({\n          status: \"fail\",\n          message: `Expected '${expectVal}' to${\n            negated ? \" not\" : \"\"\n          } be type '${expectedType}'`,\n        })\n      }\n    } else {\n      currTestStack[currTestStack.length - 1].expectResults.push({\n        status: \"error\",\n        message: `Argument for toBeType should be \"string\", \"boolean\", \"number\", \"object\", \"undefined\", \"bigint\", \"symbol\" or \"function\"`,\n      })\n    }\n\n    return { value: vm.undefined }\n  })\n\n  const toHaveLengthHandle = vm.newFunction(\n    \"toHaveLength\",\n    (expectedValHandle) => {\n      const expectedLength = vm.dump(expectedValHandle)\n\n      if (!(Array.isArray(expectVal) || typeof expectVal === \"string\")) {\n        currTestStack[currTestStack.length - 1].expectResults.push({\n          status: \"error\",\n          message: `Expected toHaveLength to be called for an array or string`,\n        })\n\n        return { value: vm.undefined }\n      }\n\n      // Check if the parameter is a number, else error\n      if (typeof expectedLength === \"number\" && !Number.isNaN(expectedLength)) {\n        let assertion = (expectVal as any[]).length === expectedLength\n        if (negated) assertion = !assertion\n\n        if (assertion) {\n          currTestStack[currTestStack.length - 1].expectResults.push({\n            status: \"pass\",\n            message: `Expected the array to${\n              negated ? \" not\" : \"\"\n            } be of length '${expectedLength}'`,\n          })\n        } else {\n          currTestStack[currTestStack.length - 1].expectResults.push({\n            status: \"fail\",\n            message: `Expected the array to${\n              negated ? \" not\" : \"\"\n            } be of length '${expectedLength}'`,\n          })\n        }\n      } else {\n        currTestStack[currTestStack.length - 1].expectResults.push({\n          status: \"error\",\n          message: `Argument for toHaveLength should be a number`,\n        })\n      }\n\n      return { value: vm.undefined }\n    }\n  )\n\n  const toIncludeHandle = vm.newFunction(\"toInclude\", (needleHandle) => {\n    const expectedVal = vm.dump(needleHandle)\n\n    if (!(Array.isArray(expectVal) || typeof expectVal === \"string\")) {\n      currTestStack[currTestStack.length - 1].expectResults.push({\n        status: \"error\",\n        message: `Expected toInclude to be called for an array or string`,\n      })\n\n      return { value: vm.undefined }\n    }\n\n    if (expectedVal === null) {\n      currTestStack[currTestStack.length - 1].expectResults.push({\n        status: \"error\",\n        message: `Argument for toInclude should not be null`,\n      })\n\n      return { value: vm.undefined }\n    }\n\n    if (expectedVal === undefined) {\n      currTestStack[currTestStack.length - 1].expectResults.push({\n        status: \"error\",\n        message: `Argument for toInclude should not be undefined`,\n      })\n\n      return { value: vm.undefined }\n    }\n\n    let assertion = expectVal.includes(expectedVal)\n    if (negated) assertion = !assertion\n\n    const expectValPretty = JSON.stringify(expectVal)\n    const expectedValPretty = JSON.stringify(expectedVal)\n\n    if (assertion) {\n      currTestStack[currTestStack.length - 1].expectResults.push({\n        status: \"pass\",\n        message: `Expected ${expectValPretty} to${\n          negated ? \" not\" : \"\"\n        } include ${expectedValPretty}`,\n      })\n    } else {\n      currTestStack[currTestStack.length - 1].expectResults.push({\n        status: \"fail\",\n        message: `Expected ${expectValPretty} to${\n          negated ? \" not\" : \"\"\n        } include ${expectedValPretty}`,\n      })\n    }\n\n    return { value: vm.undefined }\n  })\n\n  vm.setProp(resultHandle, \"toBe\", toBeFnHandle)\n  vm.setProp(resultHandle, \"toBeLevel2xx\", toBeLevel2xxHandle)\n  vm.setProp(resultHandle, \"toBeLevel3xx\", toBeLevel3xxHandle)\n  vm.setProp(resultHandle, \"toBeLevel4xx\", toBeLevel4xxHandle)\n  vm.setProp(resultHandle, \"toBeLevel5xx\", toBeLevel5xxHandle)\n  vm.setProp(resultHandle, \"toBeType\", toBeTypeHandle)\n  vm.setProp(resultHandle, \"toHaveLength\", toHaveLengthHandle)\n  vm.setProp(resultHandle, \"toInclude\", toIncludeHandle)\n\n  vm.defineProp(resultHandle, \"not\", {\n    get: () => {\n      return createExpectation(vm, expectVal, !negated, currTestStack)\n    },\n  })\n\n  toBeFnHandle.dispose()\n  toBeLevel2xxHandle.dispose()\n  toBeLevel3xxHandle.dispose()\n  toBeLevel4xxHandle.dispose()\n  toBeLevel5xxHandle.dispose()\n  toBeTypeHandle.dispose()\n  toHaveLengthHandle.dispose()\n  toIncludeHandle.dispose()\n\n  return resultHandle\n}\n\nexport const execTestScript = (\n  testScript: string,\n  envs: TestResult[\"envs\"],\n  response: TestResponse\n): TE.TaskEither<string, TestResult> =>\n  pipe(\n    TE.tryCatch(\n      async () => await qjs.getQuickJS(),\n      (reason) => `QuickJS initialization failed: ${reason}`\n    ),\n    TE.chain(\n      // TODO: Make this more functional ?\n      (QuickJS) => {\n        let currentEnvs = cloneDeep(envs)\n\n        const vm = QuickJS.createVm()\n\n        const pwHandle = vm.newObject()\n\n        const testRunStack: TestDescriptor[] = [\n          { descriptor: \"root\", expectResults: [], children: [] },\n        ]\n\n        const testFuncHandle = vm.newFunction(\n          \"test\",\n          (descriptorHandle, testFuncHandle) => {\n            const descriptor = vm.getString(descriptorHandle)\n\n            testRunStack.push({\n              descriptor,\n              expectResults: [],\n              children: [],\n            })\n\n            const result = vm.unwrapResult(\n              vm.callFunction(testFuncHandle, vm.null)\n            )\n            result.dispose()\n\n            const child = testRunStack.pop() as TestDescriptor\n            testRunStack[testRunStack.length - 1].children.push(child)\n          }\n        )\n\n        const expectFnHandle = vm.newFunction(\"expect\", (expectValueHandle) => {\n          const expectVal = vm.dump(expectValueHandle)\n\n          return {\n            value: createExpectation(vm, expectVal, false, testRunStack),\n          }\n        })\n\n        // Marshal response object\n        const responseObjHandle = marshalObjectToVM(vm, response)\n        if (E.isLeft(responseObjHandle))\n          return TE.left(\n            `Response marshalling failed: ${responseObjHandle.left}`\n          )\n\n        vm.setProp(pwHandle, \"response\", responseObjHandle.right)\n        responseObjHandle.right.dispose()\n\n        vm.setProp(pwHandle, \"expect\", expectFnHandle)\n        expectFnHandle.dispose()\n\n        vm.setProp(pwHandle, \"test\", testFuncHandle)\n        testFuncHandle.dispose()\n\n        // Environment management APIs\n        // TODO: Unified Implementation\n        const envHandle = vm.newObject()\n\n        const envGetHandle = vm.newFunction(\"get\", (keyHandle) => {\n          const key: unknown = vm.dump(keyHandle)\n\n          if (typeof key !== \"string\") {\n            return {\n              error: vm.newString(\"Expected key to be a string\"),\n            }\n          }\n\n          const result = pipe(\n            getEnv(key, currentEnvs),\n            O.match(\n              () => vm.undefined,\n              ({ value }) => vm.newString(value)\n            )\n          )\n\n          return {\n            value: result,\n          }\n        })\n\n        const envGetResolveHandle = vm.newFunction(\n          \"getResolve\",\n          (keyHandle) => {\n            const key: unknown = vm.dump(keyHandle)\n\n            if (typeof key !== \"string\") {\n              return {\n                error: vm.newString(\"Expected key to be a string\"),\n              }\n            }\n\n            const result = pipe(\n              getEnv(key, currentEnvs),\n              E.fromOption(() => \"INVALID_KEY\" as const),\n\n              E.map(({ value }) =>\n                pipe(\n                  parseTemplateStringE(value, [\n                    ...envs.selected,\n                    ...envs.global,\n                  ]),\n                  // If the recursive resolution failed, return the unresolved value\n                  E.getOrElse(() => value)\n                )\n              ),\n\n              // Create a new VM String\n              // NOTE: Do not shorten this to map(vm.newString) apparently it breaks it\n              E.map((x) => vm.newString(x)),\n\n              E.getOrElse(() => vm.undefined)\n            )\n\n            return {\n              value: result,\n            }\n          }\n        )\n\n        const envSetHandle = vm.newFunction(\"set\", (keyHandle, valueHandle) => {\n          const key: unknown = vm.dump(keyHandle)\n          const value: unknown = vm.dump(valueHandle)\n\n          if (typeof key !== \"string\") {\n            return {\n              error: vm.newString(\"Expected key to be a string\"),\n            }\n          }\n\n          if (typeof value !== \"string\") {\n            return {\n              error: vm.newString(\"Expected value to be a string\"),\n            }\n          }\n\n          currentEnvs = setEnv(key, value, currentEnvs)\n\n          return {\n            value: vm.undefined,\n          }\n        })\n\n        const envResolveHandle = vm.newFunction(\"resolve\", (valueHandle) => {\n          const value: unknown = vm.dump(valueHandle)\n\n          if (typeof value !== \"string\") {\n            return {\n              error: vm.newString(\"Expected value to be a string\"),\n            }\n          }\n\n          const result = pipe(\n            parseTemplateStringE(value, [\n              ...currentEnvs.selected,\n              ...currentEnvs.global,\n            ]),\n            E.getOrElse(() => value)\n          )\n\n          return {\n            value: vm.newString(result),\n          }\n        })\n\n        vm.setProp(envHandle, \"resolve\", envResolveHandle)\n        envResolveHandle.dispose()\n\n        vm.setProp(envHandle, \"set\", envSetHandle)\n        envSetHandle.dispose()\n\n        vm.setProp(envHandle, \"getResolve\", envGetResolveHandle)\n        envGetResolveHandle.dispose()\n\n        vm.setProp(envHandle, \"get\", envGetHandle)\n        envGetHandle.dispose()\n\n        vm.setProp(pwHandle, \"env\", envHandle)\n        envHandle.dispose()\n\n        vm.setProp(vm.global, \"pw\", pwHandle)\n        pwHandle.dispose()\n\n        const evalRes = vm.evalCode(testScript)\n\n        if (evalRes.error) {\n          const errorData = vm.dump(evalRes.error)\n          evalRes.error.dispose()\n\n          return TE.left(`Script evaluation failed: ${errorData}`)\n        }\n\n        vm.dispose()\n\n        return TE.right({\n          tests: testRunStack,\n          envs: currentEnvs,\n        })\n      }\n    )\n  )\n"]}